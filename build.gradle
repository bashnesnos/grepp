import groovy.xml.DOMBuilder
import groovy.xml.dom.DOMCategory
import groovy.xml.XmlUtil
import java.text.SimpleDateFormat

apply plugin: 'groovy'
apply plugin: 'application'

//these properties are overwritten by subprojects dev and release if they are defined there
def targetDir = new File("default") //is initialized with the project
def includeOptional = false //whether to include optional sh scripts
def params = [:] //params for used templates

//these properties are not overrided by subprojects and should be populated here. If should
def oldJdkCompatibility = 1.5//; populate if app is going to be ran on JRE older than yours. Works on 1.5
def oldJreLibPath = "C:\\Program Files\\Java\\jre1.5.0_10\\lib"//; populate if app is going to be ran on JRE older than yours. Used to set bootclasspath
def printTestClasspath = false //prints test classpath if true

repositories {
	mavenRepo name: "spring-repo", url: "http://repo.springsource.org/release"
    mavenCentral()
}

dependencies {
    compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.0.6'
	compile group: 'org.slf4j', name:'slf4j-api', version: '1.7.5'
	compile group: 'org.slf4j', name:'jcl-over-slf4j', version: '1.7.5'
	compile group: 'ch.qos.logback', name:'logback-classic', version: '1.0.11'

    compile('org.springframework:spring-beans:3.2.2.RELEASE') {
		exclude group: 'commons-logging'
	}

    if (oldJdkCompatibility == 1.5) {
        compile group: 'org.livetribe', name:'livetribe-jsr223', version: '2.0.1', transitive: true //for 1.5 compatibility
    }

    testCompile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.0.6'
	testCompile group: 'junit', name: 'junit', version: '4.10'
    
}

compileGroovy {
    if (oldJdkCompatibility) {
        sourceCompatibility = oldJdkCompatibility
        targetCompatibility = oldJdkCompatibility
        options.fork = true
        options.bootClasspath = oldJreLibPath + "\\rt.jar"
    }
}

startScripts {
    mainClassName = 'org.smlt.tools.wgrep.WGrep'
    classpath += files('/config')

    doLast {
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile    = file getUnixScript()
        windowsScriptFile.text = windowsScriptFile.text.replace('%APP_HOME%\\lib\\config', '%APP_HOME%\\config')
        windowsScriptFile.text = windowsScriptFile.text.replace('set APP_HOME=%DIRNAME%..', 'set APP_HOME=%DIRNAME%..\nset WGREP_OPTS="-Dwgrep.home=%APP_HOME%"')
        unixScriptFile.text    = unixScriptFile.text.replace('$APP_HOME/lib/config', '$APP_HOME/config')
        unixScriptFile.text    = unixScriptFile.text.replace('APP_HOME="`pwd -P`"', 'APP_HOME="`pwd -P`"\nWGREP_OPTS="-Dwgrep.home=$APP_HOME"')
    }

}

sourceSets {
	sourceSets.main.groovy.srcDir 'src/main/java' //compiling java with groovy since classes are coupled
}

jar.includes =['**/*.class'] //TODO: may be versioning or something is needed 
jar.includeEmptyDirs = false

test {
	systemProperty 'wgrep.home', rootDir.getAbsolutePath()
	def newCP = getClasspath() + project.files(rootDir.getAbsolutePath() + '/build/resources/main/config')
	setClasspath(newCP)
    if (printTestClasspath)
        newCP.getFiles().each {print it.getCanonicalPath() + ";"}
}

processTestResources {
    def dateFormat = new SimpleDateFormat('yyyy-MM-dd HH')
    def curDate = new Date()
    filter { String line ->
            line.replace('#TEST_TIME_FROM#', dateFormat.format(curDate))
                .replace('#TEST_TIME_TO#', dateFormat.format(new Date(curDate.getTime() + 60*60*1000)))
                .replace('#TEST_TIME_TOO_FAR#', dateFormat.format(new Date(curDate.getTime() + 3*60*60*1000)))
    }   
    doLast {
        mergeConfig (rootDir.getAbsolutePath() + '/build/resources/main/config/config.xml'
                    , rootDir.getAbsolutePath() + '/build/resources/test/config.custom'
                    , rootDir.getAbsolutePath() + '/build/resources/test/config.xml')
    }
}


def makeExecsFileWriter = null //leave it as null, it needs to be instantiated within a task
processResources {
    eachFile { FileCopyDetails elem ->
        def file = elem.getFile()
        def fileName = file.getName()
        if (fileName =~ /_tmplt/) {
            def tFileName = fileName.replace('_tmplt','')
            elem.setName(tFileName)
                    if (tFileName =~ /\.sh/) {
                if (!makeExecsFileWriter) {
                        makeExecsFileWriter = new FileWriter(destinationDir.getAbsolutePath() + '/optional/make_execs.sh', true) //appending to make_execs.sh    
                }
                makeExecsFileWriter.write('\nchmod +x ' + elem.getName())   
            }
                    elem.filter { String line ->
                def newLine = line
                for (param in params.keySet()) {
                    if (line =~ /$param/) newLine = newLine.replace(param, params[param])
                }
                newLine
            }
        }
    }


    doLast{
        mergeConfig (destinationDir.getAbsolutePath() + '/config/config.xml'
            , targetDir.getAbsolutePath() + '/config.custom'
            , null)
        if (makeExecsFileWriter) {
            makeExecsFileWriter.flush()
            makeExecsFileWriter.close()
        }
    }
}

task cleanSubProject(type: Delete){

}

task copyOptional(type: Copy) {
    from rootDir.getAbsolutePath() + '/build/resources/main/optional'
}

task prepareSublimeSettings(type: Copy) {
    from rootDir.getAbsolutePath() + '/src/sublime/'
    filter { String line ->
        line.replace('#WGREP_HOME#', rootDir.getAbsolutePath().replaceAll( '(\\\\)', '\\\\$1' ))
    }
    into mkdir('.sublime')
}

tasks.addRule("Pattern: install<ID>") { String taskName ->
	if (taskName.startsWith("install"))
	{
		def subProject = null
        if (taskName =~ /Dev/) {
            subProject = project(':dev')
		}
        else if (taskName ==~ /install/) {
            subProject = project(':release')

        }
        
        if (subProject)
        {

            targetDir = subProject.hasProperty('targetDir') ? subProject.targetDir : targetDir
            includeOptional = subProject.hasProperty('includeOptional') ? subProject.includeOptional : includeOptional
            oldJdkCompatibility = subProject.hasProperty('oldJdkCompatibility') ? subProject.oldJdkCompatibility : oldJdkCompatibility
            oldJreLibPath = subProject.hasProperty('oldJreLibPath') ? subProject.oldJreLibPath : oldJreLibPath
            params = subProject.hasProperty('params') ? subProject.params : params
        }
        
        def installDir = new File(targetDir.getAbsolutePath() + 'Install')
        installApp.destinationDir = installDir
        applicationDistribution.from(processResources) {
            exclude "**/optional/**"
            includeEmptyDirs = false
        }

        if (includeOptional)
            applicationDistribution.from(copyOptional.source)

        cleanSubProject.delete fileTree(installDir.getAbsolutePath())
        clean.dependsOn(':cleanSubProject')
        task(taskName, dependsOn: ':installApp') << {
        }   
	}
}

def mergeConfig(def origin, def toMerge, def target) {
    File originFile = new File(origin) 
    File mergeFile = new File(toMerge)
    if (originFile.exists() && mergeFile.exists()) { //nothing to do if the file to include does not exist
        def cfgDoc = DOMBuilder.parse(new FileReader(originFile))
        def customDoc = DOMBuilder.parse(new FileReader(mergeFile))
        def root = cfgDoc.documentElement
        use(DOMCategory) {
            root.appendChild(cfgDoc.importNode(customDoc.documentElement.custom[0], true))
        }
        cfgDoc.normalizeDocument()
        if (target == null) { //merging into origin
            XmlUtil.serialize(root, new FileWriter(originFile))    
        }
        else {
            XmlUtil.serialize(root, new FileWriter(target))    
        }
    }
    else {
        println "Check $origin and $toMerge paths"
    }
}