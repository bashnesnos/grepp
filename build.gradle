import java.text.SimpleDateFormat

apply plugin: 'groovy'
apply plugin: 'application'

version = '2.0'
//these properties are overwritten by subprojects dev and release if they are defined there
def targetDir = new File("grepp") //is initialized with the project
def includeOptional = false
def params = [:] //params for used templates

//these properties are not overrided by subprojects and should be populated here. If should
def oldJdkCompatibility = null //1.6 //; populate if app is going to be ran on JRE older than yours. Works on 1.5
def oldJreLibPath //= "C:\\Program Files\\Java\\jre1.5.0_10\\lib"//; populate if app is going to be ran on JRE older than yours. Used to set bootclasspath
def printTestClasspath = false //prints test classpath if true

repositories {
    mavenCentral()
}

dependencies {
    compile group: 'org.slf4j', name:'slf4j-api', version: '1.7.6'
    compile group: 'ch.qos.logback', name:'logback-classic', version: '1.1.1'
    compile group: 'commons-cli', name:'commons-cli', version: '1.2'

    if (oldJdkCompatibility != null) {
        if (oldJdkCompatibility =~ /1.6/) {
            compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.2.2'
            testCompile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.2.2'
        }
        if (oldJdkCompatibility =~ /1.5/) {
            compile group: 'org.livetribe', name:'livetribe-jsr223', version: '2.0.1', transitive: true //for 1.5 compatibility
        }
    }
    else {
        compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.2.2', classifier: 'indy'
        testCompile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.2.2', classifier: 'indy'
    }
    
    testCompile group: 'junit', name: 'junit', version: '4.10'
}

compileGroovy {
    if (oldJdkCompatibility != null && oldJdkCompatibility =~ /1.5/) {
        sourceCompatibility = oldJdkCompatibility
        targetCompatibility = oldJdkCompatibility
        options.fork = true
        options.bootClasspath = oldJreLibPath + "\\rt.jar"
    }
}

startScripts {
    mainClassName = 'org.smltools.grepp.cli.Grepp'
    classpath += files('/config')

    doLast {
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile    = file getUnixScript()
        windowsScriptFile.text = windowsScriptFile.text.replace('%APP_HOME%\\lib\\config', '%APP_HOME%\\config')
        windowsScriptFile.text = windowsScriptFile.text.replace('set APP_HOME=%DIRNAME%..', 'set APP_HOME=%DIRNAME%..\nset GREPP_OPTS="-Dgrepp.home=%APP_HOME%"')
        unixScriptFile.text    = unixScriptFile.text.replace('$APP_HOME/lib/config', '$APP_HOME/config')
        unixScriptFile.text    = unixScriptFile.text.replace('APP_HOME="`pwd -P`"', 'APP_HOME="`pwd -P`"\nGREPP_OPTS="-Dgrepp.home=$APP_HOME"')
    }

}

sourceSets {
	sourceSets.main.groovy.srcDir 'src/main/java' //compiling java with groovy since classes are coupled
}

jar.includes =['**/*.class'] //TODO: may be versioning or something is needed 
jar.includeEmptyDirs = false

test {
	systemProperty 'grepp.home', rootDir.getAbsolutePath() + '/build/test'
    systemProperty 'grepp.test.resources', rootDir.getAbsolutePath() + '/build/resources/test'
    systemProperty 'grepp.config', rootDir.getAbsolutePath() + '/build/resources/main/config/config.groovy'
	def newCP = getClasspath() + project.files(rootDir.getAbsolutePath() + '/build/resources/main/config')
	setClasspath(newCP)
    if (printTestClasspath) {
        newCP.getFiles().each {print it.getCanonicalPath() + ";"}
    }
    doFirst{
        def pluginFile = new File(rootDir.getAbsolutePath() + '/build/test/plugin/postFilterMethods')
        pluginFile.mkdirs()
        pluginFile = new File(pluginFile, "TestPlugin.groovy")
        pluginFile.createNewFile()
        pluginFile.write("""\
import java.util.regex.Matcher
import org.smltools.grepp.filters.PostFilterParams
import org.smltools.grepp.filters.PostFilterMethodBase

@PostFilterParams(id=\"test\")
class TestMethod extends PostFilterMethodBase<String> {
    @Override
    public String processMatchResults(Matcher mtchResults, Integer groupIdx) {
        return \"test\"
    }    
}           
""")

        pluginFile = new File(rootDir.getAbsolutePath() + '/build/test/plugin/filters')
        pluginFile.mkdirs()
        pluginFile = new File(pluginFile, "DoodkiFilter.groovy")
        pluginFile.createNewFile()
        pluginFile.write("""\
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import groovy.util.ConfigObject;
import org.smltools.grepp.exceptions.PropertiesNotFoundRuntimeException;
import org.smltools.grepp.filters.FilterBase;
import org.smltools.grepp.filters.FilterParams;
import org.smltools.grepp.filters.enums.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@FilterParams(order = 99)
public class DoodkiFilter extends FilterBase<String> {
    private static final Logger LOGGER = LoggerFactory.getLogger(DoodkiFilter.class);   

    public DoodkiFilter() {

    }

    public DoodkiFilter(Map<?, ?> config, String configId) {
        super(config);
        fillParamsByConfigIdInternal(configId)
    }

    @Override
    protected boolean fillParamsByConfigIdInternal(String configId) {
        return config.doodki.containsKey(configId);
    }

    @Override
    public ConfigObject getAsConfig(String configId) {
        return new ConfigObject();

    }

    public static boolean configIdExists(Map<?, ?> config, String configId) {
        if (config == null) {
            throw new IllegalArgumentException(\"Config can't be null!\")
        }

        return config.doodki.containsKey(configId)
    }   

    /**
     * Checks if data matches current pattern 
     * @throws IllegalArgumentException if blockData is not String
     */

    @Override
    public String filter(String blockData) {
        return \"doodki!\"
    }

}
""")
    }
}

processTestResources {
    def dateFormat = new SimpleDateFormat('yyyy-MM-dd HH')
    def curDate = new Date()
    filter { String line ->
            line.replace('#TEST_TIME_FROM#', dateFormat.format(curDate))
                .replace('#TEST_TIME_TO#', dateFormat.format(new Date(curDate.getTime() + 60*60*1000)))
                .replace('#TEST_TIME_TOO_FAR#', dateFormat.format(new Date(curDate.getTime() + 3*60*60*1000)))
    }   
}


def makeExecsFileWriter = null //leave it as null, it needs to be instantiated within a task
processResources {
    eachFile { FileCopyDetails elem ->
        def file = elem.getFile()
        def fileName = file.getName()
        if (fileName =~ /_tmplt/) {
            def tFileName = fileName.replace('_tmplt','')
            elem.setName(tFileName)
                    if (tFileName =~ /\.sh/) {
                if (!makeExecsFileWriter) {
                        makeExecsFileWriter = new FileWriter(destinationDir.getAbsolutePath() + '/optional/make_execs.sh', true) //appending to make_execs.sh    
                }
                makeExecsFileWriter.write('\nchmod +x ' + elem.getName())   
            }
                    elem.filter { String line ->
                def newLine = line
                for (param in params.keySet()) {
                    if (line =~ /$param/) newLine = newLine.replace(param, params[param])
                }
                newLine
            }
        }
    }
}

task cleanSubProject(type: Delete){

}

task copyOptional(type: Copy) {
    from rootDir.getAbsolutePath() + '/build/resources/main/optional'
}

task prepareSublimeSettings(type: Copy) {
    from rootDir.getAbsolutePath() + '/src/sublime/'
    filter { String line ->
        line.replace('#GREPP_HOME#', rootDir.getAbsolutePath().replaceAll( '(\\\\)', '\\\\$1' ))
    }
    into mkdir('.sublime')
}

task copyToIvy(type: Copy) {
    from jar
    new File('C:\\Users\\asemelit\\.grails\\ivy-cache\\org.smltools').deleteDir()
    into 'C:\\Users\\asemelit\\Documents\\GitHub\\grepp-server\\lib'
}

tasks.addRule("Pattern: install<ID>") { String taskName ->
    if (taskName.startsWith("install"))
    {
        def installDir = new File(targetDir.getAbsolutePath() + 'Install')
        installApp.destinationDir = installDir
        applicationDistribution.from(processResources) {
            exclude "**/optional/**"
            includeEmptyDirs = false
        }

        if (includeOptional)
            applicationDistribution.from(copyOptional.source)

        cleanSubProject.delete fileTree(installDir.getAbsolutePath())
        clean.dependsOn(':cleanSubProject')
        task(taskName, dependsOn: ':installApp') << {
        }   
    }
}